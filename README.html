	<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
		"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
	<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	
	</head>
	<body>
	<div class="use-texto document">
	
	<p>URWIDE</p><div class="section level-1" data-level="1"><div class="header"><h1><a class="number" name="S1"></a>Introduction</h1></div><div class="body"><p><a href="http://www.urwid.org" class="external">URWID</a> is a powerful library that allows you to write command-line interfaces in the Python language. While URWID is very powerful, it is quite low-level compared to existing UI toolkits, which can make development of more advanced user interface a bit difficult.</p><p>The main idea behind URWIDE is to extend URWID with a <em>domain-specific language to describe console-based interfaces</em>, drastically reducing the amount of code required to create console-based applications.</p><p>URWIDE's declarative, text-based UI description language supports:</p><ul><li>MVC-like architecture </li><li>Custom stylesheets </li><li>Event handling (key, focus, press, edit) </li><li>I18N (string collections)</li></ul><p>To give you an idea of what URWIDE can provide, here is a very simple <code>helloworld.py</code> example:</p><pre data-lang='python'><code>import urwide

# This is the equivalent of a CSS stylesheet
CONSOLE_STYLE = """
Frame         : Dg,  _, SO
header        : WH, DC, BO
"""

# This is the description of the actual interface
CONSOLE_UI = """\
Hdr URWIDE Hello world
___

Txt Hello World !                     args:#txt_hello
GFl
Btn [Hello !]                         &amp;press=hello
Btn [Bye   !]                         &amp;press=bye
End
"""

# This is the handling code, providing the logic
class Handler(urwide.Handler):
    def onHello( self, button ):
        self.ui.widgets.txt_hello.set_text("You said hello !")
    def onBye( self, button ):
        self.ui.end("bye !")

# We create a console application 
urwide.Console().create(CONSOLE_STYLE, CONSOLE_UI, Handler()).main()</code></pre></div></div><div class="section level-1" data-level="1"><div class="header"><h1><a class="number" name="S2"></a>UI Description Language</h1></div><div class="body"><p>URWIDE allows to describe a user interface using a very simple line-oriented language. You can define a complete UI in just a few lines. This description allows you to:</p><ul><li>Identify your widgets with a unique name </li><li>Associate detailed information and tooltip </li><li>Bind style information to your widgets </li><li>Bind event handlers</li></ul><p>The description syntax is very simple, and simply consists of a set of lines of the following form:</p><pre><code>CLS DATA? [ID|STYLE|INFO|EVENT]* [ARGUMENTS]</code></pre><p>as an example, here is the definition of a button with <code>Click me!</code> as label, which will be available as <code>btn_click</code>, displayed using the <code>clickButton</code> style, displaying the <code>CLICK</code> tooltip when focused, and calling the <code>clicked</code> callback when pressed :</p><pre><code>Btn [Click me!] #btn_click @clickButton !CLICK &amp;press=clicked</code></pre><p>To sum up the available attributes:</p><ul><li><em>CLS</em> is a three letter code that corresponds to the widget code </li><li><em>DATA</em> is a widget-specific text content </li><li><em>ID</em> sets the identifier of the widget </li><li><em>STYLE</em> sets the style class of the widget </li><li><em>EVENT</em> defines an event handler attached to the widget </li><li><em>INFO</em> defines the widget tooltip and detailed information </li><li><em>ARGUMENTS</em> defines additional widget attributes</li></ul><ul><li>Widget identifier</li></ul><pre><code>    #id</code></pre><ul><li>Widget style class</li></ul><pre><code>    @style</code></pre><ul><li>Widget tooltip</li></ul><pre><code>    !TEXT</code></pre><ul><li>Widget info</li></ul><pre><code>    ?TEXT</code></pre><ul><li>Event handling</li></ul><pre><code>    &amp;event=method</code></pre><p>Supported events:</p><ul><li><code>focus</code> </li><li><code>edit</code> </li><li><code>key</code></li></ul><ul><li>Python arguments</li></ul><pre><code>    name=value, name=value, name=value</code></pre><ul><li>Comments</li></ul><pre><code>    # This is a comment</code></pre><p>Comments are useful to annotate your URWIDE source code, or to enable/disable parts of it. Comments are simply lines starting with the <code>#</code> character.</p><div class="section level-2" data-level="2"><div class="header"><h2><a class="number" name="S2.1"></a>Blocks</h2></div><div class="body"><pre><code>Ple
Txt I am within the above pile
End</code></pre><p>or</p><pre><code>GFl
Txt Here are buttons
Btn [previous]
Btn [next]
End</code></pre><p><em>SYNTAX</em> | <em>DESCRIPTION</em> ------------------|:----------------------------------------------------- <code>#name</code> | Widget name, makes it accessible as <code>ui.widgets.name</code> <code>@class</code> | Style class associated with the widget. <code>&amp;event=callback</code> | Makes the <code>onCallback</code> method of the <code>ui.handler()</code> react to the <code>event</code> (press, key, edit, focus) when it occurs on the widget. <code>!TOOLTIP</code> | <code>ui.strings.TOOLTIP</code> or <code>"TOOLTIP"</code> is used as a tooltip for the widget (when it is focused) <code>?INFO</code> | <code>ui.strings.INFO</code> or <code>"INFO"</code> is used as information for the widget (when it is focused) <code>arg=value, ...</code> Additional Python arguments that will be passed to the widget constructor (eg. <code>multiline=true</code> for Edit) <code># comment</code> | a comment line that will be ignored when parsing</p></div></div></div></div><div class="section level-1" data-level="1"><div class="header"><h1><a class="number" name="S3"></a>Supported Widgets</h1></div><div class="body"><p>URWIDE tries to support most used URWID widgets, and also introduces <span class='term'>pseudo widgets</span> that facilitate the specification of your application layout.</p><div class="section level-2" data-level="2"><div class="header"><h2><a class="number" name="S3.1"></a>Blank</h2></div><div class="body"><pre><code>EOL</code></pre><p>A blank widget is simply an <span class='term'>empty line</span> within the UI description.</p></div></div><div class="section level-2" data-level="2"><div class="header"><h2><a class="number" name="S3.2"></a>Divider</h2></div><div class="body"><pre><code>---
===
:::</code></pre><p>These three forms create dividers composed of respectively <code>-</code>, <code>=</code> and <code>:</code> characters. In case you will want a particular pattern in your divider, you can user the following form:</p><pre><code>Dvd ~-~-</code></pre><p>Which will make you a divider composed of <code>~-~-</code>.</p></div></div><div class="section level-2" data-level="2"><div class="header"><h2><a class="number" name="S3.3"></a>Text</h2></div><div class="body"><pre><code>Txt TEXT
Txt TEXT args:ARGUMENTS</code></pre><p>Examples</p><pre><code>Txt Hello, I'm a text 
Txt Hello, I'm a text args:align='left'</code></pre><div class='tagged-block note' type='note'>
Be sure to use the <code>args:</code> prefix to give arguments to the text, because
otherwise your arguments will be interpreted as being part of the
displayed text.</div></div></div><div class="section level-2" data-level="2"><div class="header"><h2><a class="number" name="S3.4"></a>Button</h2></div><div class="body"><pre><code>Btn [LABEL]</code></pre></div></div><div class="section level-2" data-level="2"><div class="header"><h2><a class="number" name="S3.5"></a>Choice</h2></div><div class="body"><pre><code>Chc [ :group] I am an unselected option
Chc [X:group] I am a selected option
Chc [X:other] I am a selected option from the 'other' group
Chc [ :group] I am an unselected option args:#my_choice</code></pre><p>A choice is composed of:</p><ul><li>Its <span class='term'>state</span> and <span class='term'>group</span> represented by the leading <code>[S:GROUP]</code>, where <code>S</code> is either <code> </code> or <code>X</code> and <code>GROUP</code> is any string. Groups are availabled in as <code>ui.groups.GROUP</code> (<code>ui.groups</code> is a <code>UI.Collection</code> instance)</li></ul><ul><li>Its <span class='term'>label</span>, following the state and group definition. It can be free-form text.</li></ul><ul><li>The <span class='term'>ui arguments</span>, optionally following the label, but prefixed by <code>args:</code></li></ul></div></div><div class="section level-2" data-level="2"><div class="header"><h2><a class="number" name="S3.6"></a>Pile</h2></div><div class="body"><pre><code>Ple
...
End</code></pre></div></div><div class="section level-2" data-level="2"><div class="header"><h2><a class="number" name="S3.7"></a>Gridflow</h2></div><div class="body"><pre><code>Gfl 
...
End</code></pre></div></div><div class="section level-2" data-level="2"><div class="header"><h2><a class="number" name="S3.8"></a>Box</h2></div><div class="body"><pre><code>Box border=1
...
End</code></pre><p>Boxes allow to draw a border around a widget. You can simply indicate the size of the border using the <code>border</code> attribute.</p></div></div><div class="section level-2" data-level="2"><div class="header"><h2><a class="number" name="S3.9"></a>Columns</h2></div><div class="body"><pre><code>Col
    ***
End</code></pre></div></div><div class="section level-2" data-level="2"><div class="header"><h2><a class="number" name="S3.10"></a>Summary</h2></div><div class="body"><p><em>CODE</em> | <em>WIDGET</em> |<em>TYPE</em> -------|:-------------------|:------------------------------------------ <code>Txt</code> <a class="anchor" name="Text"></a> widget <code>Edt</code> <a class="anchor" name="Edit"></a> widget <code>Btn</code> <a class="anchor" name="Button"></a> widget <code>Chc</code> <a class="anchor" name="RadioButton"></a> widget <code>Dvd</code> <a class="anchor" name="Divider"></a> widget <code>Ple</code> <a class="anchor" name="Pile"></a> container <code>GFl</code> <a class="anchor" name="GridFlow"></a> container <code>Box</code> | Box (not in URWID) | container</p></div></div></div></div><div class="section level-1" data-level="1"><div class="header"><h1><a class="number" name="S4"></a>Event handling</h1></div><div class="body"><p>URWIDE provides support for handling events and binding event handlers to each individual widget. The events currently supported are:</p><ul><li><code>focus</code> (any), which is triggered when the widget received focus </li><li><code>key</code> (any), which is triggered when a key is pressed on a widget </li><li><code>edit</code> (Edit), which is triggered after an Edit was edited </li><li><code>press</code> (Buttons, CheckBox), which is triggered when a button is pressed</li></ul><p>Events are handled by <span class='term'>handlers</span>, which are objects that define methods that implement a particular reaction. For instance, if you have an event named <code>showHelp</code>, you handler class will be like that:</p><pre><code>class MyHandler(urwide.Handler):

    def onShowHelp( self, widget ):
        # Do something here</code></pre><p>And then, if you want to trigger the &ldquo;<span class='quote'>`showHelp`</span>&rdquo; event when a button is pressed:</p><pre><code>Btn [Show help] &amp;press=showHelp</code></pre><p>This will automatically make the binding between the ui and the handler, provided that you register your handler into the ui:</p><pre><code>ui.handler(MyHandler())</code></pre></div></div><div class="section level-1" data-level="1"><div class="header"><h1><a class="number" name="S5"></a>Collections</h1></div><div class="body"><p>URWIDE will create an instance of the <code>urwide.UI</code> class when given a style (will be presented later) and a UI description. This instance will take care of everything for you, from events to widgets. You will generally only want to access or modify the <code>widgets</code> and <code>strings</code> collections.</p><p>Both collections can be edited by accessing values as attribute. Setting an attribute will add a key within the collection, accessing it will return the bound value, or raise an exception if the value was not found.</p><pre><code>ui.strings.SOME_TEXT = "This text can be used as a value in a widget"

ui.widgets</code></pre></div></div><div class="section level-1" data-level="1"><div class="header"><h1><a class="number" name="S6"></a>Style syntax</h1></div><div class="body"><pre><code>[STYLE] : FG, BG, FN</code></pre><ul><li><span class='term'>STYLE</span> is the name of the style </li><li><span class='term'>FG</span> is the foreground color </li><li><span class='term'>BG</span> is the backgrond color </li><li><span class='term'>FN</span> is the font style</li></ul><p>A style name can be:</p><ul><li><span class='term'>URWID widget name</span> (<code>Edit</code>, <code>Text</code>, etc) </li><li><span class='term'>style name</span> (defined by <code>@style</code> in the widgets list) </li><li><span class='term'>widget id</span>, as defined by the <code>#id</code> of the UI</li></ul><p>Focus styles can be specified by appending <code>*</code> to each style name:</p><pre><code>Edit        : BL, _, SO
Edit*       : DM, Lg, SO</code></pre><p>means that all <code>Edit</code> widgets will have black as color when unfocused, and dark magenta when focused.</p><p>Here is a table that sums up the possible values that can be used to describe the styles. These values are described in the URWID reference for the <a href="http://excess.org/urwid/reference.html#Screen-register_palette_entry" class="external">Screen</a> class.</p><p><em>CODE</em> | <em>VALUE</em> |<em>FOREGROUND</em>|<em>BACKGROUND</em>| <em>FONT</em> -------|:--------------|:-----------|:-----------|:------------------- WH <a class="anchor" name="white"></a> yes <a class="anchor" name="no"></a> - BL <a class="anchor" name="black"></a> no <a class="anchor" name="yes"></a> - YL <a class="anchor" name="yellow"></a> yes <a class="anchor" name="no"></a> - BR <a class="anchor" name="brown"></a> yes <a class="anchor" name="no"></a> - DR <a class="anchor" name="dark_red"></a> no <a class="anchor" name="yes"></a> - DB <a class="anchor" name="dark_blue"></a> yes <a class="anchor" name="yes"></a> - DG <a class="anchor" name="dark_green"></a> yes <a class="anchor" name="yes"></a> - DM <a class="anchor" name="dark_magenta"></a> yes <a class="anchor" name="yes"></a> - DC <a class="anchor" name="dark_cyan"></a> yes <a class="anchor" name="yes"></a> - Dg <a class="anchor" name="dark_gray"></a> yes <a class="anchor" name="no"></a> - LR <a class="anchor" name="light_red"></a> yes <a class="anchor" name="no"></a> - LG <a class="anchor" name="light_green"></a> yes <a class="anchor" name="no"></a> - LB <a class="anchor" name="light_blue"></a> yes <a class="anchor" name="no"></a> - LM <a class="anchor" name="light_magenta"></a> yes <a class="anchor" name="no"></a> - LC <a class="anchor" name="light_cyan"></a> yes <a class="anchor" name="no"></a> - Lg <a class="anchor" name="light_gray"></a> yes <a class="anchor" name="yes"></a> - BO <a class="anchor" name="bold"></a> - | - <a class="anchor" name="yes
UL"></a> underline | - | - <a class="anchor" name="yes
SO"></a> standout | - | - <a class="anchor" name="yes
_"></a> default <a class="anchor" name="yes"></a> yes | yes</p><p>Using dialogs:</p><pre data-lang='python'><code>    dialog = Dialog()
    # Don't know why this is necessary, but it doesn't work if it's not there
    sialog.handler(dialog_handler)
    self.pushHandler(dialog_handler)

    def dialog_end():
        self.popHandler()</code></pre></div></div>
	
	</div>
	</body>
	</html>